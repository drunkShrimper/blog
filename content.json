[{"title":"Java容器","date":"2020-05-09T12:43:18.000Z","path":"2020/05/09/Java容器/","text":"","tags":[]},{"title":"二叉树的非递归遍历","date":"2020-04-29T05:13:34.000Z","path":"2020/04/29/二叉树的非递归遍历/","text":"","tags":[]},{"title":"旋转数组","date":"2020-04-24T03:37:10.000Z","path":"2020/04/24/旋转数组/","text":"","tags":[]},{"title":"单例模式","date":"2020-04-17T14:37:15.000Z","path":"2020/04/17/单例模式/","text":"","tags":[]},{"title":"Java中boolean占多大内存","date":"2020-04-17T14:36:40.000Z","path":"2020/04/17/Java中boolean占多大内存/","text":"Java的八种基本数据类型中，除了其它七种类型都有明确的内存占用字节数外，就boolean类型没有给出具体的占用字节数，因为对虚拟机来说根本就不存在 boolean 这个类型，boolean类型在编译后会使用int类型来表示，，如果是true则转换为1，如果是false则转化为0。 在《Java虚拟机规范》一书中讲到：“虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位”。","tags":[{"name":"Java","slug":"Java","permalink":"http://lipan.fun/tags/Java/"}]},{"title":"Java引用本身占多大内存","date":"2020-04-17T14:36:03.000Z","path":"2020/04/17/Java引用本身占多大内存/","text":"声明一个对象，该对象会在堆中占有一定的内存，那么我们有没有想过，这个引用本身占多大内存呢？ 引用占用的是栈内存的空间（用来放地址的），这个空间的大小是多少？ 最直观的想法是，引用本身的大小和操作系统的内存空间有关，在64位平台上，占8个字节，在32位平台上占4个字节，这个应该是很自然的事情，因为32-bit的操作系统，在4G(2^32)的内存空间内找到某个地址，这个地址是用4bytes(32 bits)来表示的。但事实是这样吗？ 引用本身是保留在栈中的，引用所指的对象，是存放在堆中的。在HotsPot64位平台，引用本身的大小是4个字节，保存的是压缩指针。java虚拟机规定中，方法区中占用内存以字节为最小单位，但是在栈帧中以字为最小单位。如byte类型在方法区中它占用8位，为一个字节，但是在栈帧中以一个字，即32位来处理，其实就是当作一个int类型来处理。这也恰好印证了引用本身的大小是4个字节。","tags":[{"name":"Java","slug":"Java","permalink":"http://lipan.fun/tags/Java/"}]},{"title":"生产者与消费者问题的经典实现","date":"2020-04-09T08:06:19.000Z","path":"2020/04/09/生产者与消费者问题的经典实现/","text":"问题描述生产者消费者问题，也称有限缓冲问题，是一个多线程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个线程（或多个）——即“生产者”和“消费者”。 生产者的作用是生成一定量的数据放到缓冲区中，生产者会源源不断的进行生产重复此过程。 消费者在缓冲区中消耗这些数据，而且会源源不断的消费。 此问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者不会在缓冲区中空时消耗数据。 要解决该问题，就必须让生产者在缓冲区满时休眠（wait），等到下次消费者消耗缓冲区中的数据的时候，生产者才能被唤醒（notify），开始往缓冲区添加数据。同理，在缓冲区空时让消费者进入休眠（wait），等到生产者往缓冲区添加数据之后，再唤醒（notify）消费者。 通常采用进程间通信的方法解决该问题。如果解决方法不够完善，则容易出现死锁的情况。出现死锁时，两个线程都会陷入休眠，等待对方唤醒自己（但是永远也等不到）。 核心设计本次实现采用的是Java线程通信中最经典的wait和notify方式。 wait 该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。但是使用这个方法一定要注意，必须要将其包裹在一个循环内，否则会造成虚假唤醒的问题。最终导致死锁。 虚假唤醒：当一个条件满足时，很多线程都被唤醒了，但是只有其中部分是有用的唤醒，其它的唤醒都是无用的，甚至是有害的。比如在生产者消费者问题中，假如有3个生产者在wait状态，而此时某个消费者消费了1个数据然后调用了notifyAll，3个在wait状态的生产者如果同时被唤醒，就会同时进行生产，线程同步被破坏了。 怎么解决呢，我们看看官方文档： A thread can also wake up without being notified, interrupted, or timing out, a so-called spurious wakeup. While this will rarely occur in practice, applications must guard against it by testing for the condition that should have caused the thread to be awakened, and continuing to wait if the condition is not satisfied. In other words, waits should always occur in loops, like this one: 大意是： 线程可能会在不被通知、中断或超时的情况下唤醒，即所谓的虚假唤醒。虽然这种情况在实际中很少发生，但应用程序必须通过，并在条件不满足时继续等待来防范这种情况。换句话说，等待应该总是以循环的形式出现，就像下面这样： 12345synchronized (obj) &#123; while (&lt;condition does not hold&gt;) obj.wait(timeout); ... // Perform action appropriate to condition&#125; 重点：测试本应导致线程被唤醒的条件（如使用while实现） 这样做的结果是，在wait状态的线程被notify后，即使能够被唤醒，接下来还要进行while语句的条件判断，而不是直接执行被唤醒后的代码逻辑。 notify 该方法在同步方法或同步块中调用， 该方法任意从WAITTING状态的线程中挑选一个进行通知，使得调用wait()方法的线程从等待队列移入到同步队列中，等待有机会再一次获取到锁，从而使得调用wait()方法的线程能够从wait()方法处退出。调用notify后，当前线程不会马上释放该对象锁，要等到程序退出同步块后，当前线程才会释放锁。 notifyAll 该方法与 notify ()方法的工作方式相同，重要的一点差异是： notifyAll 使所有原来在该对象上 wait 的所有线程均退出WAITTING状态，使得他们全部从等待队列中移入到同步队列中去，等待下一次能够有机会获取到锁。 代码实现 123456789101112131415161718192021222324252627282930313233public class Box &#123; private int product = 0; public synchronized void add() &#123; while (10 &lt;= product) &#123; System.out.println(Thread.currentThread().getName() + \": 箱子已满\"); try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; product++; System.out.println(Thread.currentThread().getName() + \": 生产了1件商品-----目前共有\" + product +\"件产品\"); this.notifyAll(); &#125; public synchronized void consume() &#123; while (0 == product) &#123; System.out.println(Thread.currentThread().getName() + \": 箱子为空\"); try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; product--; System.out.println(Thread.currentThread().getName() + \": 消费了1件商品-----目前共有\" + product +\"件产品\"); this.notifyAll(); &#125;&#125; 12345678910111213141516171819public class Productor implements Runnable &#123; private Box box; public Productor(Box box) &#123; this.box = box; &#125; public void run() &#123; while (true) &#123; try &#123; Thread.sleep((int) (Math.random() * 100 + 1)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; box.add(); &#125; &#125;&#125; 1234567891011121314151617181920public class Consumer implements Runnable &#123; private Box box; public Consumer(Box box) &#123; this.box = box; &#125; public void run() &#123; while (true) &#123; try &#123; Thread.sleep((int) (Math.random() * 105 + 1)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; box.consume(); &#125; &#125;&#125; 12345678910111213public class ProductorAndConsumerTest &#123; public static void main(String[] args) &#123; Box box = new Box(); //注意：生产者和消费者要对同一个对象进行操作，即作用于同一个缓冲区 Productor pro = new Productor(box); Consumer con = new Consumer(box); for (int i = 0; i &lt; 3; i++) &#123; new Thread(pro, \"生产者\" + i).start(); new Thread(con,\"消费者\" + i).start(); &#125; &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://lipan.fun/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"http://lipan.fun/tags/多线程/"},{"name":"虚假唤醒","slug":"虚假唤醒","permalink":"http://lipan.fun/tags/虚假唤醒/"}]},{"title":"50道sql练习题","date":"2020-04-07T15:51:36.000Z","path":"2020/04/07/50道sql练习题/","text":"在网上找的50道SQL练习（使用Oracle）数据表创建 学生表 Student 12345678910111213create table Student(SId varchar(10),Sname varchar(10),Sage date,Ssex varchar(10));insert into Student values('01' , '赵雷' , to_date('1990-01-01','yyyy-MM-dd') , '男');insert into Student values('02' , '钱电' , to_date('1990-12-21','yyyy-MM-dd') , '男');insert into Student values('03' , '孙风' , to_date('1990-12-20','yyyy-MM-dd') , '男');insert into Student values('04' , '李云' , to_date('1990-12-06','yyyy-MM-dd') , '男');insert into Student values('05' , '周梅' , to_date('1991-12-01','yyyy-MM-dd') , '女');insert into Student values('06' , '吴兰' , to_date('1992-01-01','yyyy-MM-dd') , '女');insert into Student values('07' , '郑竹' , to_date('1989-01-01','yyyy-MM-dd') , '女');insert into Student values('09' , '张三' , to_date('2017-12-20','yyyy-MM-dd') , '女');insert into Student values('10' , '李四' , to_date('2017-12-25','yyyy-MM-dd') , '女');insert into Student values('11' , '李四' , to_date('2012-06-06','yyyy-MM-dd') , '女');insert into Student values('12' , '赵六' , to_date('2013-06-13','yyyy-MM-dd') , '女');insert into Student values('13' , '孙七' , to_date('2014-06-01','yyyy-MM-dd') , '女'); 科目表 Course 1234create table Course(CId varchar(10),Cname varchar(10),TId varchar(10));insert into Course values('01' , '语文' , '02');insert into Course values('02' , '数学' , '01');insert into Course values('03' , '英语' , '03'); 教师表 Teacher 1234create table Teacher(TId varchar(10),Tname varchar(10));insert into Teacher values('01' , '张三');insert into Teacher values('02' , '李四');insert into Teacher values('03' , '王五'); 成绩表 SC 12345678910111213141516171819create table SC(SId varchar(10),CId varchar(10),score decimal(18,1));insert into SC values('01' , '01' , 80);insert into SC values('01' , '02' , 90);insert into SC values('01' , '03' , 99);insert into SC values('02' , '01' , 70);insert into SC values('02' , '02' , 60);insert into SC values('02' , '03' , 80);insert into SC values('03' , '01' , 80);insert into SC values('03' , '02' , 80);insert into SC values('03' , '03' , 80);insert into SC values('04' , '01' , 50);insert into SC values('04' , '02' , 30);insert into SC values('04' , '03' , 20);insert into SC values('05' , '01' , 76);insert into SC values('05' , '02' , 87);insert into SC values('06' , '01' , 31);insert into SC values('06' , '03' , 34);insert into SC values('07' , '02' , 89);insert into SC values('07' , '03' , 98); 练习题目题组1题型1 查询” 01 “课程比” 02 “课程成绩高的学生的信息及课程分数 1234select t1.*,t2.score 课程02分数 from (select * from SC natural join student where sc.cid = '01') t1, (select * from SC natural join student where sc.cid = '02') t2where t1.score &gt; t2.score and t1.sid = t2.sid; 查询同时存在” 01 “课程和” 02 “课程的情况 1234select t1.*,t2.score 课程02分数 from (select * from SC natural join student where sc.cid = '01') t1, (select * from SC natural join student where sc.cid = '02') t2where t1.sid = t2.sid; 查询存在” 01 “课程但可能不存在” 02 “课程的情况(不存在时显示为 null ) 1234select t1.*,t2.score 课程02分数 from (select * from SC natural join student where sc.cid = '01') t1 left join(select * from SC natural join student where sc.cid = '02') t2on t1.sid = t2.sid; 查询不存在” 01 “课程但存在” 02 “课程的情况 123select * from (select * from SC natural join student where sc.cid = '02') where sid not in(select sid from SC where cid = '01') ; 题型2 查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩 1234select s.sid,s.sname,t.avg_score from student s, (select sid,avg(score) avg_score from SC group by sid) t where s.sid = t.sid and t.avg_score&gt;60; 1234select s.sid,s.sname,t.avg_score from student s, (select sid,avg(score) avg_score from SC group by sid having avg(score)&gt;60) twhere s.sid = t.sid; 题型3 查询在 SC 表存在成绩的学生信息 1select * from student where sid in (select distinct sid from SC); 1select DISTINCT student.* from student,sc where student.SId=sc.SId; 题型4 查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null ) 1234select s.sid,s.sname,t.count_course,t.sum_score from student s, (select sid,count(cid) count_course,sum(score) sum_score from SC group by sid) t where s.sid = t.sid; 12345select s.sid,s.sname,t.count_course,t.sum_score from student s left join (select sid,count(cid) count_course,sum(score) sum_score from SC group by sid) t on s.sid = t.sid; 查有成绩的学生信息 这里涉及到一个知识点：当表2的记录数量非常大的时候，选用exists比in要高效很多 EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False.结论：IN()适合B表比A表数据小的情况结论：EXISTS()适合B表比A表数据大的情况 1select * from student where sid in (select distinct sid from SC); 12select * from student where exists (select sc.sid from sc where student.sid = sc.sid); 题型5 查询「李」姓老师的数量 1select count(*) from teacher where tname like '李_%'; 题型6 查询学过「张三」老师授课的同学的信息 先上一种笨方法 1234select * from student where sid in (select sid from sc where cid = ( select cid from course where tid = (select tid from teacher where tname = '张三'))); 下面的方法一开始理解起来有些困难，但这是很普通的多表联查 123456select student.* from student,teacher,course,scwhere student.sid = sc.sid and course.cid=sc.cid and course.tid = teacher.tid and tname = '张三'; 题型7 查询没有学全所有课程的同学的信息 第一种做法忽略了有的学生一门课都没学的情况（所以其sid不会出现在SC表） 123select * from student where sid in (select sid from sc group by sid having count(cid) &lt;(select count(cid) from course)); 正确的做法应该是先查出修了所有课程的学生，再求其相对于所有学生集的补集 123456select * from studentwhere student.sid not in ( select sc.sid from sc group by sc.sid having count(sc.cid)= (select count(cid) from course)); 题型8 查询至少有一门课与学号为” 01 “的同学所学相同的同学的信息 思路：student表要和SC表作联合查询这是毫无疑问的，在查询时要多加一个限制条件“课程id要属于学号为” 01 “的同学所学的课程id集合” 同理可以使用natural join，实质上natural join跟表联查是等价的。 123select distinct student.* from student,SC where SC.cid in (select cid from SC where sid = '01') and student.sid=SC.sid; 题型9 查询和” 01 “号的同学学习的课程完全相同的其他同学的信息 这题本来不用写这么长但是由于这个操作：”取一个中间表的某字段最大的记录（即：top N问题）“使得这个查询变得很长，实际上没有这么长 分析： 首先取出sid为“01”的学生学习的所有课程的cid，这个应该不难 然后根据SC表中每个学生的每门成绩有且仅有一条记录这个原则： 查询出SC中所有学生中有学习“01”学生学习的课程的记录 对上一条操作得到的中间表进行分组（根据sid），并计算count(cid) 如果某学生的count(cid)和”01“学生的count(cid)相同，则说明他们所学习的课程完全一样。同样的，如果某学生的count(cid)小于”01“学生的count(cid)，说明他学的课有和”01“学生相同的，但没有学完”01“学生学的所有课。如果某学生并不在这个查询结果内，说明他学的课没有一门是”01“学生学的课。 最后根据题目要求还要排除“01”学生这条记录 1234567select s.* from student s,(select * from (select sid,count(cid) same_num from SC where cid in (select cid from SC where sid = '01') group by sid)where same_num = (select count(cid) from SC where sid ='01')) twhere s.sid =t.sid and s.sid &lt;&gt; '01'; 123456select s.* from student s,(select sid from SC where cid in (select cid from SC where sid = '01') group by sid havingcount(cid) = (select count(cid) from SC where sid ='01')) twhere s.sid =t.sid and s.sid &lt;&gt; '01'; 题型10 查询没学过”张三”老师讲授的任一门课程的学生姓名 这题思路跟题型7一样，要查没学过“张三”老师的课的学生，应该先查学过的，在求补集。如果直接求的话，会出现有人一门课都没学过的情况。 123select * from student where sid not in (select sid from sc where cid in (select cid from course where tid = (select tid from teacher where tname = '张三') )); 12345678select * from studentwhere student.sid not in( select sc.sid from sc,course,teacher where sc.cid = course.cid and course.tid = teacher.tid and teacher.tname= \"张三\"); 题组2题型1 查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩 12345select s.sid 学号,s.sname 姓名,t2.avg_score 平均成绩 from student s,(select sid from sc where score&lt;60 group by sid having count(cid)&gt;1) t1,(select sid,avg(score) avg_score from sc group by sid) t2where t1.sid = t2.sid and s.sid = t1.sid; 题型2 检索” 01 “课程分数小于 60，按分数降序排列的学生信息 123select * from student natural join sc where score &lt;60 and cid = '01' order by score desc ; 题型3 按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩 此题本身难倒是不难，反而是如何显示要下一番功夫 1234select * from (select * from sc union select sid,'avg' cid,avg(score) score from sc group by sid) order by sid,case when cid = 'avg' then 1 else 0 end asc,score desc; 题型4 查询各科成绩最高分、最低分和平均分： 以如下形式显示：课程 ID，课程 name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率 及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90 要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列 这里没有查出课程名，如果要查的话natural join一下course表即可 12345678910111213select cid 课程ID,count(*) 选修人数,max(sc.score) 最高分,min(sc.score) 最低分,AVG(sc.score) 平均分,sum(case when sc.score&gt;=60 then 1 else 0 end )/count(*) 及格率,sum(case when sc.score&gt;=70 and sc.score&lt;80 then 1 else 0 end )/count(*) 中等率,sum(case when sc.score&gt;=80 and sc.score&lt;90 then 1 else 0 end )/count(*) 优良率,sum(case when sc.score&gt;=90 then 1 else 0 end )/count(*) 优秀率 from scGROUP BY cidORDER BY count(*) DESC, cid ASC; 题型5 按各科成绩进行排序，并显示排名， Score 重复时保留名次空缺 思路: 首先查出比自己高分的记录有多少条，注意利用左连接的特点使得第一名（因为没有人比他高分，不使用左连接的话会没有第一名的记录比较麻烦）能被记录。 1234select *from sc a left join sc b on a.score&lt;b.score and a.cid = b.cid order by a.sid; 在得到的上表中，对于sid来说有多少条记录就说明排名是多少,但是因为需求是 Score 重复时保留名次空缺，因此不用count(a.sid)(或count(a.cid),count(a.score))而是使用count(b.score)+1,这样在计数比自己高的人数时就不会把自己算进去（因为使用的是left join,自己那一条记录的b.score是为null 的） 123456select a.cid, a.sid, a.score, count(b.score)+1 rankfrom sc a left join sc b on a.score&lt;b.score and a.cid = b.cidgroup by a.cid, a.sid,a.scoreorder by a.cid, rank ASC; 按各科成绩进行排序，并显示排名， Score 重复时不保留名次空缺 此题与题型6的第2题情况一样 题型6 查询学生的总成绩，并进行排名，总分重复时保留名次空缺 与题型5第1题解法类似 12345select t.sid,t.score,count(t2.score)+1 rank from (select sid,sum(score) score from sc group by sid) t left join (select sid,sum(score) score from sc group by sid) t2 on t.score&lt;t2.score group by t.sid,t.score order by count(*); 查询学生的总成绩，并进行排名，总分重复时不保留名次空缺 这题没什么好思路，直接抄的别人的答案。在SQL里面变量用@来标识。但是在Oracle中的语法好像不是这样定义变量的，还是说应该使用plsql来解决？（下面是mysql的解法） 12345set @crank=0;select q.sid, total, @crank := @crank +1 as rank from(select sc.sid, sum(sc.score) as total from scgroup by sc.sidorder by total desc)q; 题型7 统计各科成绩各分数段人数：课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0] 及所占百分比 这里要注意case when 条件 then 1 else 0 end的原理，它是返回数值1或0，如果使用count来接收的话，不论是1还是0都会计数。效果跟count(*)一样，所以此处应该使用sum来计数，如果还不明白，将sum(case when 条件 then 2 else 0 end)和count(case when 条件 then 2 else 0 end)查询一下就明白了。 1234567891011121314select cid,cname,sum(case when score&gt;=85 and score &lt;=100 then 1 else 0 end) \"[100-85]人数\",sum(case when score&gt;=70 and score &lt;85 then 1 else 0 end) \"[85-70]人数\",sum(case when score&gt;=60 and score &lt;70 then 1 else 0 end) \"[70-60]人数\",sum(case when score&gt;=0 and score &lt;60 then 1 else 0 end) \"[60-0]人数\",round(sum(case when score&gt;=85 and score &lt;=100 then 1 else 0 end)/count(*),2) \"[100-85]比例\",round(sum(case when score&gt;=70 and score &lt;85 then 1 else 0 end)/count(*),2) \"[85-70]比例\",round(sum(case when score&gt;=60 and score &lt;70 then 1 else 0 end)/count(*),2) \"[70-60]比例\",round(sum(case when score&gt;=0 and score &lt;60 then 1 else 0 end)/count(*),2) \"[60-0]比例\"from sc natural join course group by cid,cname; 题型8 查询各科成绩前三名的记录 这个题目还是有点麻烦，因为Oracle不支持像mysql里面的limit语法。这里查询了一下资料，可以使用OVER(PARTITION BY)函数。附上一篇讲解博客。 123select * from (select sc.*,row_number() over(partition by cid order by score desc ) rank from sc) where rank &lt; 4; 但是上面的解法有个问题，如果有相同分数的就有点难办了。所以还是得用“找出比自己高分的人数”的思路来确定自己的排名。解法如下： 123select * from scwhere (select count(*) from sc a where sc.cid = a.cid and sc.score&lt;a.score )&lt; 3order by cid asc, sc.score desc; 题组3题目1 查询每门课程被选修的学生数 查成绩单上每门课对应的记录条数即可。 1select cid,count(*) from sc group by cid; 题目2 查询出只选修两门课程的学生学号和姓名 1select sid,sname from sc natural join student group by sid,sname having count(*) =2; 题目3 查询男生、女生人数 1select ssex 性别,count(*) 人数 from student group by ssex; 题目4 查询名字中含有「风」字的学生信息 1select *from student where sname like '%风%'; 题目5 查询同名同性学生名单，并统计同名人数 123select s1.sname 姓名,count(*) 人数 from student s1,student s2 where s1.sid &lt;&gt; s2.sid and s1.sname = s2.sname group by s1.sname; 题目6 查询 1990 年出生的学生名单 注：在Oracle里面没有year()函数 1select * from student where to_char(sage,'YYYY') = '1990' ; 题目7 查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列 123select cname,cid,round(avg(score),2) from sc natural join course group by cid,cname order by avg(score) desc,cid asc; 题目8 查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩 1select sid,sname,round(avg(score),2) from student natural join sc group by sname,sid having avg(score) &gt;=85; 题目9 查询课程名称为「数学」，且分数低于 60 的学生姓名和分数 1234select sname,score from sc,course,student where sc.cid = course.cid and course.cname = '数学' and sc.sid = student.sid and sc.score&lt;60; 题目10 查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况） 123select student.sid,sname,cname,score from student left join (select * from sc natural join course) t on student.sid = t.sid; 题组4题目1 查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数 123select sname,cname,score from student natural join sc natural join coursewhere score&gt;70; 解法2： 1234select student.sname, course.cname,sc.score from student,course,scwhere sc.score&gt;70and student.sid = sc.sidand sc.cid = course.cid; 题目2 查询存在有人不及格的课程 1select distinct cname from sc natural join course where score &lt; 60; 题目3 查询课程编号为 01 且课程成绩在 80 分以上的学生的学号和姓名 1select sid,sname from sc natural join student where score &gt;= 80 and cid = '01'; 题目4 求每门课程的学生人数 1select cname,count(sid) from sc natural join course group by cname; 题目5 成绩不重复，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩 要注意一个老师是可以有多门课的，这里的数据恰好是只有一门课。 1234567select student.*,t.* from sc ,student,(select cid,max(score) score from sc where cid in(select cid from course natural join teacher where tname ='张三') group by cid) twhere sc.sid = student.sid and sc.cid = t.cid and sc.score = t.score; 题目6 查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩 12select t1.* from sc t1 inner join sc t2 on t1.cid = t2.cid and t1.score = t2.score and t1.sid &lt;&gt; t2.sid order by t1.cid; 题目7 查询每门课成绩排名前2的学生 这题在Oracle里面还是比较麻烦，解题思路跟题组2 题型5差不多 1234select t1.cid,t1.sid,count(*) from sc t1 left join sc t2 on t2.score&gt;t1.score and t1.sid &lt;&gt; t2.sid and t1.cid = t2.cid group by t1.cid,t1.sid having count(*)&lt;=2 order by cid; 题目8 统计每门课程的学生选修人数（超过 5 人的课程才统计） 1select cid,count(*) from sc group by cid having count(*) &gt;5; 题目9 检索至少选修两门课程的学生学号 1select sid from sc group by sid having count(cid) &gt;=2 order by sid; 题目10 查询选修了全部课程的学生信息 12select * from student where sid in (select sid from sc group by sid having count(cid) =(select count(*) from course)); 题组5题目1 查询各学生的年龄，只按年份来算 1select sname,round(months_between(sysdate,sage)/12,0) 年龄 from student; 题目2 查询本周过生日的学生 在oracle里面貌似比较难实现… 思路：首先将出生日期的年份替换为当前年份，然后看这个日期是今年的第几周，是否与当前时间是当前第几周相同。（感觉解法是错的…有待研究） 123select sid from student where to_char(add_months(sage,(to_char(sysdate,'yyyy') - to_char(sage,'yyyy'))*12),'ww') = to_char(sysdate,'ww'); 题目3 查询下周过生日的学生 这题要考虑边界情况，如果下周是下一年了就比较难搞了…（有待研究） 12 题目4 查询本月过生日的学生 1select * from student where to_char(sysdate,'MM') = to_char(sage,'MM'); 题目5 查询下月过生日的学生 1select * from student where MOD(to_char(sysdate,'MM')+1,13)= to_char(sage,'MM');","tags":[{"name":"SQL","slug":"SQL","permalink":"http://lipan.fun/tags/SQL/"},{"name":"Oracle","slug":"Oracle","permalink":"http://lipan.fun/tags/Oracle/"},{"name":"数据库","slug":"数据库","permalink":"http://lipan.fun/tags/数据库/"}]},{"title":"B+Tree与MySQL索引","date":"2020-04-07T04:50:59.000Z","path":"2020/04/07/B+Tree与MySQL索引/","text":"","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://lipan.fun/tags/数据结构/"},{"name":"MySQL","slug":"MySQL","permalink":"http://lipan.fun/tags/MySQL/"},{"name":"树","slug":"树","permalink":"http://lipan.fun/tags/树/"},{"name":"索引","slug":"索引","permalink":"http://lipan.fun/tags/索引/"}]},{"title":"TCP三次握手四次挥手","date":"2020-04-05T02:02:18.000Z","path":"2020/04/05/TCP三次握手四次挥手/","text":"TCP报文格式 源端口号：表示发送端端口号，字段长16位。 目的端口：表示接收端端口号，字段长度16位。 序号：字段长32位。序列号是指发送数据的位置。每发送一次数据，就累加一次该数据字节数的大小。序列号不会从0或1开始，而是在建立连接时由计算机生成的随机数作为其初始值通。然后再将每转发过去的字节数累加到初始值上表示数据的位置。例如序号为401，表示第一个字节的编号为 401，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 501。此外，在建立连接和断开连接的时发送的SYN包和FIN包虽然并不携带数据，但是也会作为一个字节增加对应的序列号。 确认号：确认应答号字段长度为32位。是指下一次应该收到的数据的序列号。实际上，它是指已收到确认应答号减一为止的数据。发送端接收到这个确认应答号以后可以认为在这个序列号以前的数据都已经被正常接收。 数据偏移：该字段表示TCP所传输的数据部分应该从TCP包的哪个位开始，可以把它看做TCP首部的长度。该字段长为4字节。 保留：该字段主要是为了以后扩展时使用，其长度为4位，一般设置为0，但即使收到的包在该字段不为0，此包也不会被丢弃。 控制位：字段长为8位，每一个从左到至右分别为URG ACK PSH RST SYN FIN。这些控制标志也叫作控制位。当它们对应位上的值为1时，具体含义如下： URG：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。 ACK：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。 PSH：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。 RST：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。 SYN：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。 FIN：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。 窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。 校验和：奇偶校验，此校验和是对整个的 TCP 报文段，包括 TCP 头部和 TCP 数据，以 16 位字进行计算所得。由发送端计算和存储，并由接收端进行验证。 紧急指针：只有当 URG 标志置 1 时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。 选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。 数据部分： TCP 报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有 TCP*首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。 三次握手 A 为客户端，B 为服务器端。 三次握手过程 B(服务器端) 处于监听状态，等待客户的连接请求。 A 主动向 B 发送连接请求报文，SYN=1，ACK=0，选择一个随机选择的seq（序号） x。 B 收到来自A的请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号ack为 x+1，同时也选择一个序号 y。 A 收到 B 的连接确认报文后，还要向 B 发出确认，ACK=1，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 为什么需要三次握手 关键点：请求滞留 正常情况下，A发出连接请求，如果因为连接报文请求丢失而未收到确认，客户端等待一个超时重传时间之后，就会重新请求连接。于是A再重传一次连接请求，B后来收到了请求，并进行确认，建立了连接，数据传输完毕后，就释放链接。这是正常情况下，A共发送了两次连接请求报文段，其中第一个丢失，第二个到达了B。 考虑这样一种情况，A发送的请求报文连接段并没有丢失，而是在网络中滞留较长时间，以致延误到某个时间到达B，本来是一个早已失效的报文段，但是B收到了此失效连接请求报文段后，就误以为A又重新发送的连接请求报文段，并发送确认报文段给A，同意建立连接，如果没有三次握手，那么B发送确认后，连接就建立了。 这种情况下，由于A并没有主动建立这个连接，于是不理会B的确认，也不会给B发送数据，而B会一直等待A发送数据，如果没有第三次握手，会导致B的资源浪费。如果有第三次握手，服务器只有收到第三次握手的确认消息才会去建立连接，避免重复打开连接。 四次挥手 四次挥手过程 A 发送连接释放报文，FIN=1，seq=u。 B 收到之后发出确认,ACK=1,seq=v,ack=u+1。此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。（考点：在半关闭状态下服务器端报文丢失会重传吗？—&gt;） 当 B 不再需要连接时，发送连接释放报文，FIN=1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。 为什么需要四次挥手 关键点：收到客户端的请求不会立即关闭SOCKET 在三次握手时，当服务端收到客户端的SYN连接请求后，可以直接回复SYN+ACK报文，同意进行连接。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，”你发的FIN报文我收到了”。等到服务端将剩余的所有的报文都发送完了，才能发送FIN报文，因此不能一起发送。故需要四次挥手。 四次挥手释放连接时，等待2MSL的意义 MSL：Maximum Segment Lifetime，“最大报文存活时间” 如果最后客户端返回的 ACK 号丢失了，结果会如何呢？这时，服务器没有接收到 ACK 号，可能会重发一次 FIN。如果这时客户端的套接字已经删除了，会发生什么事呢？套接字被删除，那么套接字中保存的控制信息也就跟着消失了，套接字对应的端口号就会被释放出来。 这时，如果别的应用程序要创建套接字，新套接字碰巧又被分配了同一个端口号 ，而服务器重发的 FIN 正好到达，会怎么样呢？本来这个 FIN 是要发给刚刚删除的那个套接字的，但新套接字具有相同的端口号，于是这个 FIN 就会错误地跑到新套接字里面，新套接字就开始执行断开操作了。之所以不马上删除套接字，就是为了防止这样的误操作。","tags":[{"name":"TCP","slug":"TCP","permalink":"http://lipan.fun/tags/TCP/"}]},{"title":"基础排序算法","date":"2020-04-04T15:31:24.000Z","path":"2020/04/04/基础排序算法/","text":"参考CYC大佬的设计思想（[https://cyc2018.github.io/CS-Notes/#/notes/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F](https://cyc2018.github.io/CS-Notes/#/notes/算法 - 排序)），设计以下抽象类。使得待排序的元素必需实现 Java 的 Comparable 接口，该接口有 compareTo() 方法，用来判断两个元素的大小关系。 123456789101112131415161718192021public abstract class Sort&lt;T extends Comparable&lt;T&gt;&gt; &#123; public abstract void sort(T[] datas); protected boolean less(T v, T w) &#123; return v.compareTo(w) &lt; 0; &#125; protected void swap(T[] a, int i, int j) &#123; T t = a[i]; a[i] = a[j]; a[j] = t; &#125; protected void show(T[] array)&#123; for(int i=0;i&lt;array.length;i++)&#123; System.out.print(\" \"+array[i]); &#125; System.out.println(); &#125;&#125; 其中冒泡，插入，基数，归并属于稳定排序； 选择，快速，希尔，堆属于不稳定排序","tags":[{"name":"排序","slug":"排序","permalink":"http://lipan.fun/tags/排序/"}]},{"title":"KMP算法","date":"2020-04-04T12:36:43.000Z","path":"2020/04/04/KMP算法/","text":"输入样例1234567894oadhifgoarhglkdsaoarabcdefgdecalgeojflasojfjfaweiofof 输出样例12348057 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include \"stdio.h\"#include \"stdlib.h\"#include \"iostream.h\"#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define INFEASLBLE -1#define OVERFLOW -2#define MAXSTRLEN 255 //用户可在255以内定义最大串长typedef unsigned char SString[MAXSTRLEN + 1]; //0号单元存放串的长度int next[10000];void get_next(SString T, int next[])&#123; //i&lt;j是恒成立的（在第i个位置匹配失败最好情况是对比第i-1个，j最大值是i-1） int i = 1, j = 0; next[1] = 0; while (i &lt; T[0]) &#123; if (j == 0 || T[i] == T[j]) &#123; ++i; ++j;//巧妙地得到了下一次要比较的位置 j next[i] = j; &#125; else &#123; j = next[j];//第j个字母失配，接下来从第next[j]个开始对比 &#125; &#125;&#125;int Index_KMP(SString S, SString T, int pos)&#123; int i = pos, j = 1; //j一旦超过模式串长度则匹配成功，i超过主串长度且j没有超出长度则匹配失败 while (i &lt;= S[0] &amp;&amp; j &lt;= T[0]) &#123; //成功匹配（j肯定不为0）则匹配下一个字符 或 第一个就不匹配（j=0,j++就变为1，刚好重新匹配） if (j == 0 || S[i] == T[j]) &#123; ++i; ++j; &#125; else &#123; j = next[j]; &#125; &#125; if (j &gt; T[0])//j一旦超过模式串长度则匹配成功 &#123; return i - T[0]; &#125; else &#123; return 0; &#125;&#125;int main()&#123; SString T, S; int i, j, n; char ch; int pos; scanf(\"%d\",&amp;n); // 指定n对需进行模式匹配的字符串 ch = getchar(); for (j = 1; j &lt;= n; j++) &#123; ch = getchar(); for ( i = 1; i &lt;= MAXSTRLEN &amp;&amp; (ch != '\\n'); i++) // 录入主串 &#123; S[i] = ch; ch = getchar(); &#125; S[0] = i - 1; // S[0]用于存储主串中字符个数 ch = getchar(); for ( i = 1; i &lt;= MAXSTRLEN &amp;&amp; (ch != '\\n'); i++) // 录入模式串 &#123; T[i] = ch; ch = getchar(); &#125; T[0] = i - 1; // T[0]用于存储模式串中字符个数 pos =Index_KMP(S, T,0); printf(\"%d\\n\", pos); &#125;&#125;","tags":[{"name":"KMP","slug":"KMP","permalink":"http://lipan.fun/tags/KMP/"},{"name":"算法","slug":"算法","permalink":"http://lipan.fun/tags/算法/"}]},{"title":"为什么重写equals方法需同时重写hashCode方法","date":"2020-04-04T09:24:41.000Z","path":"2020/04/04/为什么重写equals方法需同时重写hashCode方法/","text":"12345678910111213141516171819202122232425262728public class MyTest &#123; private static class Person&#123; String name; public Person(String name) &#123; this.name = name; &#125; @Override public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o == null || getClass() != o.getClass())&#123; return false; &#125; Person person = (Person) o; return this.name.equals(o.name); &#125; &#125; public static void main(String []args)&#123; HashMap&lt;Person,String&gt; map = new HashMap&lt;Person, String&gt;(); Person person = new Person(\"张三\"); map.put(person,\"张三\"); //从逻辑上讲应该能输出“张三” System.out.println(\"结果:\"+map.get(new Person(\"张三\"))); &#125;&#125; 上述程序的输出结果为null 这是因为在put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，变量person最终索引位置是由其hashcode的值来决定的 ，而当我们想通过new Person(&quot;张三&quot;)取出value的时候这个匿名变量的hashcode与变量person的hashcode并不相等，导致计算出的数组下标不同，因此HashMap找不到该key对应的值，返回null。","tags":[{"name":"Java","slug":"Java","permalink":"http://lipan.fun/tags/Java/"}]},{"title":"HashMap精解","date":"2020-04-03T08:34:01.000Z","path":"2020/04/03/HashMap精解/","text":"1.哈希表哈希表的添加，删除，查找等操作，性能十分之高，在没有发生哈希冲突的情况下，仅需一次定位即可完成，时间复杂度为O(1)。哈希表的本质是一个数组，数组是采用一段连续的存储单元来存储数据的数据结构。当我们知道下标时，在数组中查找元素的时间复杂度为O(1)。哈希表正是利用了这个特性。 当我们要新增或查找某个元素，最关键的是找到存放该元素的数组下标。 如何计算数组下标？我们知道每一个对象都有一个哈希值 12345678public class DemoTest &#123; public static void main(String[] args) &#123; System.out.println(\"aasdfdsf\".hashCode()); System.out.println(\"adfsdf\".hashCode()); System.out.println(\"cdffdf\".hashCode()); &#125;&#125; 输出结果： 可以发现这些哈希值会很大，有时还有负数，怎么能作为数组下标呢，有一种简单的办法是：取余 取余就是一个简单的哈希函数 哈希冲突可以发现，对于两个元素的哈希值经过哈希函数处理后的结果可能是相同的。如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？这种情况就是所谓的哈希冲突。 HashMap采用了链地址法解决哈希冲突 2.HashMapHashMap的主干是一个Entry数组。，每一个Entry包含一个key-value键值对，以及指向其下一个节点的指针。所以说Entry其实就是一个节点。下面是部分源码： 123456static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Node&lt;K,V&gt; next; ...&#125; 所以，HashMap的总体结构可以想象成： 通常说HashMap由数组+链表组成的，这是指JDK1.7之前的HashMap 当然，在HashMap中的哈希函数肯定不是取余这么简单，在JDK1.7中的哈希函数大体可以理解为将哈希值与HashMap的大小-1进行二进制与操作 下面具体看一下： 1234hash(int) 0000 0000 0000 0000 0000 0000 1010 1010 &amp;HashMap长度（默认16）- 1 0000 0000 0000 0000 0000 0000 0000 1111结果 0000 0000 0000 0000 0000 0000 0000 1010 可以发现，任何一个数与HashMap长度（默认16）- 1进行&amp;操作后都只会得到一个小于HashMap长度（默认16）的一个数。这样便实现是计算数组下标的功能。这也是为什么HashMap的大小必须是2的幂次方数。（因为2^n-1的前半部分必为0，后半部分必为1。任何一个数与这样的数相与刚好是0-2^n-1的一个数，正好用作数组下标） 如果你输入一个非2的幂次方数，HashMap会自动计算一个最接近的且&gt;所输入数的2的幂次方数 123456private static int roundUpToPowerOf2(int number) &#123; // assert number &gt;= 0 : \"number must be non-negative\"; return number &gt;= MAXIMUM_CAPACITY ? MAXIMUM_CAPACITY : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1; &#125; 但是在HashMap中还有更精细的处理。 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 可以发现，在获取hash值时HashMap并不是简单的返回key.hashCode()而是进行了这样的操作： (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16) 这当于将hashCode的前16位与后16位异或 这是Java设计者认为在计算数组下标时，hashCode的前半段很少会参与到计算中（由HashMap长度决定），这样会导致哈希冲突经常发生，因此作出这样的处理。 3.HashMap扩容12345678910111213141516171819/**阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold*/int threshold;/**负载因子，代表了table的填充度有多少，默认是0.75加载因子存在的原因，还是因为减缓哈希冲突，如果初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。所以加载因子默认为0.75，也就是说大小为16的HashMap，到了第13个元素，就会扩容成32。*/final float loadFactor;void addEntry(int hash, K key, V value, int bucketIndex) &#123; //当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容 if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex);&#125; 通过2 * table.length可以知道，HashMap扩容后的容量是原来的2倍，这个2倍也是有讲究的，参考HashMap计算数组下标的原理（上文已提）就知道了。因为这个特征，扩容后的HashMap上的各个元素的位置要么保持不变，要么为原位置+原HashMap长度。 原理： 123456789101112131415161718192021情况一（扩容后下标 不变）：hash(int) 0000 0000 0000 0000 0000 0000 1010 1010 &amp;HashMap长度（默认16）- 1 0000 0000 0000 0000 0000 0000 0000 1111 0000 0000 0000 0000 0000 0000 0000 1010hash(int) 0000 0000 0000 0000 0000 0000 1010 1010 &amp;HashMap长度（扩容后）- 1 0000 0000 0000 0000 0000 0000 0001 1111 0000 0000 0000 0000 0000 0000 0000 1010情况二（扩容后下标为 原下标+16）：hash(int) 0000 0000 0000 0000 0000 0000 1011 1010 &amp;HashMap长度（默认16）- 1 0000 0000 0000 0000 0000 0000 0000 1111 0000 0000 0000 0000 0000 0000 0000 1010hash(int) 0000 0000 0000 0000 0000 0000 1011 1010 &amp;HashMap长度（扩容后）- 1 0000 0000 0000 0000 0000 0000 0001 1111 0000 0000 0000 0000 0000 0000 0001 1010 4.HashMap的get方法HashMap的get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。（HashMap的键可以为null）,如果key不为null，则通过哈希函数计算其数组下标，然后遍历链表，找到对应的value。 12345678910111213141516final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125; int hash = (key == null) ? 0 : hash(key); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; 5.JDK1.7后的HashMap当同一个数组下标对应的链表上数据过多导致性能下降该怎么办（链表的查询速度较慢）？ JDK1.8对HashMap进行性能优化，当链表长度超过8时，链表会转换为红黑树，当红黑树节点小于6时，红黑树会转换回链表。 红黑树的插入、查找等操作较快。 红黑树的讲解见另一篇帖子。","tags":[{"name":"Java","slug":"Java","permalink":"http://lipan.fun/tags/Java/"},{"name":"数据结构","slug":"数据结构","permalink":"http://lipan.fun/tags/数据结构/"},{"name":"HashMap","slug":"HashMap","permalink":"http://lipan.fun/tags/HashMap/"}]},{"title":"红黑树精讲","date":"2020-04-03T08:16:42.000Z","path":"2020/04/03/红黑树精讲/","text":"","tags":[{"name":"Java","slug":"Java","permalink":"http://lipan.fun/tags/Java/"},{"name":"树","slug":"树","permalink":"http://lipan.fun/tags/树/"}]},{"title":"百问Java","date":"2020-04-02T15:28:42.000Z","path":"2020/04/02/百问Java/","text":"Q1：简述JDK8的新特性答：①接口中可以添加default修饰的非抽象方法，可以有方法体和内容。②可以使用lambda表达式，减少代码冗余。③函数式接口，使用@FunctionalInterface注解标明，该接口有且仅有一个抽象方法。④方法引用，可以直接引用已有Java类或对象的方法或构造器，进一步简化lambda表达式。⑤stream流，用于解决已有集合/数组类库的弊端，简化其操作，有foreach遍历、filter过滤、map映射、concat合并等功能。⑥增加日期相关的API。 Q2：Stream流了解吗？答：①Stream流是JDK1.8的新特性，用于解决已有集合/数组类库的弊端，简化集合/数组的操作。②stream流的获取：集合：直接调用stream()方法获取；数组：使用静态方法Stream.of()/Arrays.stream()获取。③常用方法：forEach() 遍历；count() 统计个数；filter() 按条件过滤；limit() 取前面n个元素；skip() 跳过前面n个元素；map() 映射加工；concat() 合并stream流。④终结方法：foreach/count 调用终结方法后流不能继续使用；非终结方法：每次调用完返回一个新的stream对象，可以继续使用，支持链式编程。⑤收集stream流：把流转为Set集合 collect(Collections.toSet())；把流转为List集合 collect(Collections.toList())；把流转为Collection集合 collect(Collections.toCollection())；把流转为数组 toArray()。","tags":[{"name":"Java","slug":"Java","permalink":"http://lipan.fun/tags/Java/"},{"name":"面试题","slug":"面试题","permalink":"http://lipan.fun/tags/面试题/"}]},{"title":"Java泛型基础","date":"2020-04-02T15:28:13.000Z","path":"2020/04/02/Java泛型基础/","text":"为什么要有泛型集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，在使用时确定类型，这个类型参数叫做泛型。Collection，List，ArrayList 这个就是类型参数，即泛型。 使用泛型的主要优点是能够在编译时而不是在运行时检测错误。 泛型的概念所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。 在集合中使用泛型T只能是类，不能用基本数据类型填充。但可以使用包装类填充 123456789101112ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();//类型推断list.add(78);list.add(88);for(Integer i : list)&#123; System.out.println(i);&#125;Iterator&lt;Integer&gt; iterator = list.iterator();while(iterator.hasNext())&#123; System.out.println(iterator.next());&#125; 自定义泛型自定义泛型类 泛型声明 interface List&lt;T&gt; 和 class GenTest&lt;K,V&gt;其中，T,K,V不代表值，而是表示类型。这里使用任意字母都可以。常用T表示，是Type的缩写。 泛型的实例化 一定要在类名后面指定类型参数的值（类型）。如： 12List&lt;String&gt; strList = new ArrayList&lt;String&gt;();Iterator&lt;Customer&gt; iterator = customers.iterator(); 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价 jdk1.7，泛型的简化操作：ArrayList flist = new ArrayList&lt;&gt;(); 泛型的继承/实现 父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型 12345678910111213141516class Father&lt;T1, T2&gt; &#123;&#125;// 子类不保留父类的泛型// 1)没有类型 擦除class Son1 extends Father &#123;// 等价于class Son extends Father&lt;Object,Object&gt;&#123;&#125;// 2)具体类型class Son2 extends Father&lt;Integer, String&gt; &#123;&#125;// 子类保留父类的泛型// 1)全部保留class Son3&lt;T1, T2&gt; extends Father&lt;T1, T2&gt; &#123;&#125;// 2)部分保留class Son4&lt;T2&gt; extends Father&lt;Integer, T2&gt; &#123;&#125; 12345678910111213141516class Father&lt;T1, T2&gt; &#123;&#125;// 子类不保留父类的泛型// 1)没有类型 擦除class Son&lt;A, B&gt; extends Father&#123;//等价于class Son extends Father&lt;Object,Object&gt;&#123;&#125;// 2)具体类型class Son2&lt;A, B&gt; extends Father&lt;Integer, String&gt; &#123;&#125;// 子类保留父类的泛型// 1)全部保留class Son3&lt;T1, T2, A, B&gt; extends Father&lt;T1, T2&gt; &#123;&#125;// 2)部分保留class Son4&lt;T2, A, B&gt; extends Father&lt;Integer, T2&gt; &#123;&#125; 使用示例： 1234567891011121314151617181920212223242526272829303132class Person&lt;T&gt; &#123; // 使用T类型定义变量 private T info; // 使用T类型定义一般方法 public T getInfo() &#123; return info; &#125; public void setInfo(T info) &#123; this.info = info; &#125; // 使用T类型定义构造器 public Person() &#123; &#125; public Person(T info) &#123; this.info = info; &#125;// static的方法中不能声明泛型// public static void show(T t) &#123;// &#125;// 不能在try-catch中使用泛型定义// public void test() &#123;// try &#123;// &#125; catch (MyException&lt;T&gt; ex) &#123;// &#125;// &#125;&#125; 泛型方法12345678910111213141516171819202122public class DemoTest &#123; public static &lt;T&gt; void fromArrayToCollection(T[] a, Collection&lt;T&gt; c) &#123; for (T o : a) &#123; c.add(o); &#125; &#125; public static void main(String[] args) &#123; Object[] ao = new Object[100]; Collection&lt;Object&gt; co = new ArrayList&lt;Object&gt;(); fromArrayToCollection(ao, co); String[] sa = new String[20]; Collection&lt;String&gt; cs = new ArrayList&lt;&gt;(); fromArrayToCollection(sa, cs); Collection&lt;Double&gt; cd = new ArrayList&lt;&gt;(); // 下面代码中T是Double类，但sa是String类型，编译错误。 // fromArrayToCollection(sa, cd); // 下面代码中T是Object类型，sa是String类型，可以赋值成功。 fromArrayToCollection(sa, co); &#125;&#125; 通配符List&lt;?&gt;是List、List等各种泛型List的父类。 12345public static void main(String[] args) &#123; List&lt;?&gt; list = null; list = new ArrayList&lt;String&gt;(); list = new ArrayList&lt;Double&gt;();&#125; 将任意元素加入到其中不是类型安全的 null例外 1234567public static void main(String[] args) &#123; List&lt;?&gt; list = null; list = new ArrayList&lt;String&gt;(); list = new ArrayList&lt;Double&gt;(); // list.add(3);//编译不通过 list.add(null);&#125; 不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用? 12public static &lt;?&gt; void test(ArrayList&lt;?&gt; list)&#123;&#125; 不能用在泛型类的声明上 12class GenericTypeClass&lt;?&gt;&#123;&#125; 不能用在创建对象上 1ArrayList&lt;?&gt; list2 = new ArrayList&lt;?&gt;(); 通配符的上下限 上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口，或其本身，即&lt;= 12&lt;? extends Number&gt;只允许泛型为Number及Number子类的引用调用 下限super：使用时指定的类型不能小于操作的类，即&gt;= 12&lt;? super Number&gt;只允许泛型为Number及Number父类的引用调用","tags":[{"name":"Java","slug":"Java","permalink":"http://lipan.fun/tags/Java/"},{"name":"泛型","slug":"泛型","permalink":"http://lipan.fun/tags/泛型/"}]},{"title":"Java多线程基础","date":"2020-04-02T05:25:58.000Z","path":"2020/04/02/Java多线程基础/","text":"基本概念：程序、进程、线程 程序(program)：可以认为是一组为完成特定任务、用某种语言编写的指令的集合。通常存放在硬盘中，是一种特殊的文件。 进程(process)：是程序的一次执行过程，或是正在运行的一个程序，可以理解为程序的一个实例。进程有其生命周期：创建、就绪、执行、阻塞和终止状态。通常操作系统为进程分配资源。 线程(thread)：线程是一个程序内部的一条执行路径。若一个进程同一时间并行执行多个线程，就称这个程序是支持多线程的。线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程向进程请求资而不是操作系统，操作系统并不知道线程的存在。 JDK1.5之前线程创建的两种方法1.继承Thread类的方式 定义子类继承Thread类。 子类中重写Thread类中的run方法。 123456public class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(this.getName()+\"--启动了！\"); &#125;&#125; 创建Thread子类对象，即创建了线程对象。 调用线程对象start方法：启动线程，调用run方法。 123456public class DemoTest &#123; public static void main(String[] args) &#123; Thread thread = new MyThread(); thread.start(); &#125;&#125; 2.实现Runnable接口的方式 定义子类，实现Runnable接口。 子类中重写Runnable接口中的run方法。 123456public class MyThread implements Runnable &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()+\"--启动了！\"); &#125;&#125; 通过Thread类含参构造器创建线程对象。 将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。 调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。 123456public class DemoTest &#123; public static void main(String[] args) &#123; Thread thread = new Thread(new MyThread()); thread.start(); &#125;&#125; 线程的生命周期 新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源 运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态 死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束 线程同步当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据的错误。 典型的由于线程同步造成问题的例子：售票问题 123456789101112131415161718192021222324252627282930public class MyThread implements Runnable &#123; private int ticket = 100; @Override public void run() &#123; while (true) &#123; if (ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName()+ \"售出车票，车票号为：\" + ticket--); &#125; else &#123; break; &#125; &#125; &#125;&#125;public class DemoTest &#123; public static void main(String[] args) &#123; Thread t = new Thread(new MyThread()); Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); t1.setName(\"t1窗口\"); t2.setName(\"t2窗口\"); t3.setName(\"t3窗口\"); t1.start(); t2.start(); t3.start(); &#125;&#125; 当极端请况出现时，ticket的值有可能为0或负数 解决办法： Synchronized ：对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。 同步代码块 123synchronized (某对象)&#123;// 需要被同步的代码;&#125; 同步方法 123public synchronized void func (String name)&#123;//&#125; 对于并发工作，当两个线程访问相同的资源时， 防止冲突的方法就是当资源被一个线程使用时，在其上加锁。第一个访问某项资源的线程必须锁定这项资源，使其他线程在其在使用该资源期间无法访问该资源，只有在解锁之后，其他线程才可以锁定并使用该资源。 JDK5.0 新增线程创建方式 可以有返回值 可以抛出异常 支持泛型的返回值 需要借助FutureTask类，比如获取返回结果 方式1：实现Callable 接口Future接口可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等。FutrueTask是Futrue接口的唯一的实现类，同时实现了Runnable, Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值 Future位于java.util.concurrent包下 12345678public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; cancel方法用来取消任务 isCancelled方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。 isDone方法表示任务是否已经完成 get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回； get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。 使用示例： 1234567891011121314151617181920212223242526272829public class MyThread implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(Thread.currentThread().getName()+\"--启动了\"); int sum = 0; for(int i=0;i&lt;100;i++)&#123; sum += i; &#125; return sum; &#125;&#125;public class DemoTest &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); FutureTask&lt;Integer&gt; task = new FutureTask&lt;&gt;(myThread); new Thread(task).start(); try &#123; System.out.println(\"task运行结果\"+task.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 方式2：使用线程池 Executor、ExecutorService Executor:一个接口，其定义了一个接收Runnable对象的方法executor用来执行一个任务 123public interface Executor &#123; void execute(Runnable command);&#125; ExecutorService接口对Executor接口进行了扩展，提供了返回Future对象，终止，关闭线程池等方法。 1234567public interface ExecutorService extends Executor &#123; void shutdown(); &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException;&#125; 使用示例： 123456789101112131415161718192021222324252627282930313233343536public class MyThread implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; int sum = 0; for (int i = 0; i &lt; 100; i++) &#123; sum += i; &#125; return sum; &#125;&#125;public class DemoTest &#123; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); List&lt;Future&lt;Integer&gt;&gt; resultList = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 10; i++)&#123; Future&lt;Integer&gt; future = executorService.submit(new MyThread()); resultList.add(future); &#125; for (Future&lt;Integer&gt; future : resultList)&#123; try&#123; System.out.println(future.get()); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125;catch(ExecutionException e)&#123; e.printStackTrace(); &#125;finally&#123; executorService.shutdown(); &#125; &#125; &#125;&#125; Executors Java提供的工具类、线程池的工厂类，用于创建并返回不同类型的线程池 12345678//创建一个可根据需要创建新线程的线程池Executors.newCachedThreadPool()//创建一个可重用固定线程数的线程池Executors.newFixedThreadPool(n)//创建一个只有一个线程的线程池Executors.newSingleThreadExecutor()//创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。Executors.newScheduledThreadPool(n) 使用示例： 1234567891011121314151617181920212223242526272829303132333435363738394041public class MyThread implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; System.out.println(Thread.currentThread().getName()+\"--启动了\"); int sum = 0; for(int i=0;i&lt;100;i++)&#123; sum += i; &#125; return sum; &#125;&#125;public class DemoTest &#123; public static void main(String[] args) throws Exception &#123; // 1. 创建固定线程池 ExecutorService executorService = Executors.newFixedThreadPool(3); // 2. 创建一组异步任务 List&lt;Callable&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;(); list.add(new MyThread()); list.add(new MyThread()); list.add(new MyThread()); // 3. 提交一组异步任务, 会阻塞主线程 List&lt;Future&lt;Integer&gt;&gt; futures = executorService.invokeAll(list); // 4. 主线程被阻塞, 不能执行其它任务 System.out.println(\"主线程被阻塞---\"); // 5. 获取返回结果, 此时所有异步任务已执行完毕, 所以不再有阻塞 System.out.println(\"主线程继续执行---\"); for (Future&lt;Integer&gt; future : futures) &#123; System.out.println(future.get()); &#125; // 6.关闭线程池 executorService.shutdown(); &#125;&#125; 自定义线程池 123456789101112131415161718192021222324252627282930313233343536373839public class MyThread implements Runnable &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + \"正在执行...\"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;public class DemoTest &#123; public static void main(String[] args) &#123; BlockingQueue&lt;Runnable&gt; blockingQueue = new ArrayBlockingQueue&lt;Runnable&gt;(20); ThreadPoolExecutor pool = new ThreadPoolExecutor(3,5,50,TimeUnit.MILLISECONDS,blockingQueue); Runnable t1 = new MyThread(); Runnable t2 = new MyThread(); Runnable t3 = new MyThread(); Runnable t4 = new MyThread(); Runnable t5 = new MyThread(); Runnable t6 = new MyThread(); Runnable t7 = new MyThread(); pool.execute(t1); pool.execute(t2); pool.execute(t3); pool.execute(t4); pool.execute(t5); pool.execute(t6); pool.execute(t7); pool.shutdown(); &#125;&#125;","tags":[{"name":"Java","slug":"Java","permalink":"http://lipan.fun/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"http://lipan.fun/tags/多线程/"}]},{"title":"多个串的公共子序列","date":"2019-11-05T02:50:09.000Z","path":"2019/11/05/多个串的公共子序列/","text":"题目描述给出N个字符串，求出N个公共最长子串的长度。 详细讲解撰写中… 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;int n;int a[1000000+10] = &#123;0&#125;;int len[110]= &#123;0&#125;;int xlen[110]= &#123;0&#125;;string str[110];int getXlen()&#123; for(int i=1; i&lt;n; i++) &#123; xlen[i] = 1; for(int j=1; j&lt;=i; j++) &#123; xlen[i] *= len[j] ; &#125; &#125;&#125;int mapping(int x[])&#123; int idx = x[1] ; for(int i=2; i&lt;=n; i++) &#123; idx += x[i]*xlen[i-1]; &#125; return idx;&#125;int deMapping(int m,int x[])&#123; for(int i=0; i&lt;=n; i++) x[i] = 0; for(int i=n-1; i&gt;0&amp;&amp;m!=0; i--) &#123; x[i+1] = m/xlen[i]; m = m%xlen[i] ; &#125; x[1] = m;&#125;int getF(int x[])&#123; return a[mapping(x)];&#125;void setF(int x[],int value)&#123; a[mapping(x)] = value;&#125;bool hasZero(int x[])&#123; int i; for(i=1; i&lt;=n; i++) &#123; if(x[i] == 0) return true; &#125; return false;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1; i&lt;=n; i++) &#123; cin&gt;&gt;str[i]; len[i] = str[i].size() +1; &#125; getXlen(); int x[n+1] = &#123;0&#125;; for(int i=1; i&lt;=n; i++) x[i] = 0; setF(x,0); int total_len = 1; for(int i = 1; i&lt;=n; i++) &#123; total_len *= len[i]; &#125; for(int i=0; i&lt;=total_len; i++) &#123; a[i] =0; &#125; for(int i=1; i&lt;=total_len; i++) &#123; deMapping(i,x); if(hasZero(x)) &#123; setF(x,0); &#125; else &#123; int flag = 1; for(int j=1; j&lt;n; j++) &#123; if(str[j][x[j]-1] != str[j + 1][x[j+1]-1] ) &#123; flag = 0; break; &#125; &#125; if(flag) &#123; int tmp[n+1]; for(int j = 1; j&lt;=n; j++) &#123; tmp[j] = x[j]-1; &#125; setF(x,getF(tmp) + 1) ; &#125; else &#123; int tmp[n+1],max_sub = 0; for(int j = 0; j&lt;=n; j++) tmp[j] = x[j]; for(int j=1; j&lt;=n; j++) &#123; tmp[j-1] ++; tmp[j] --; if(getF(tmp) &gt; max_sub) max_sub = getF(tmp); &#125; setF(x,max_sub); &#125; &#125; &#125; int result = 0; for(int i=1;i&lt;=total_len;i++)&#123; if( a[i] &gt; result) result =a[i]; &#125; cout&lt;&lt;result; return 0;&#125;","tags":[{"name":"算法","slug":"算法","permalink":"http://lipan.fun/tags/算法/"},{"name":"动态规划","slug":"动态规划","permalink":"http://lipan.fun/tags/动态规划/"}]},{"title":"算法理论之NP问题","date":"2019-09-17T12:20:44.000Z","path":"2019/09/17/算法理论之NP问题/","text":"基础知识回顾要了解上面的算法概念，首先要回顾一下这两个基本的数学概念 多项式函数 形如：形如 Pn(x)=a(n)x^n+a(n-1)x^(n-1)+…+a(1)x+a(0)的函数，叫做多项式函数 例如：y=kx+b 就是一个次数是1的多项式函数，y=ax^2+bx+c就是一个次数为2的多项式函数 时间复杂度 这个东西用大白话来讲就是衡量一个算法优劣的最重要指标，例如冒泡算法的时间复杂度是o(n^2)，其中n是指数据的规模。这里面的n^2就是一个多项式。 那么什么是p类问题例如冒泡算法的时间复杂度是o(n^2)，它是一个多项式时间的算法问题，所以我们将之称为P类问题(P：polynominal，多项式)。 NP问题的定义NP类问题：能在多项式时间内验证得出一个正确解的问题。(NP:Nondeterministic polynominal，非确定性多项式) P类问题是NP问题的子集，因为存在多项式时间解法的问题，总能在多项式时间内验证他。 如何理解NP问题呢？ 我们可以这样想：有一个问题，你不知道是否存在一个多项式算法来解决它，但是你可以通过一次次的猜测（或者说尝试）从而有机会在一个多项式的时间呢找出他的解。这种不确定性就可以称之为N。这样的问题就是NP问题啦。 NPC问题NPC问题:如果所有np问题都能在多项式时间内转化为他，则称该np问题为npc问题(NPC:NP complete又叫NP完全问题) 那么啥叫问题的转化呢？我们用最直白的想法来理解就是：要解决一个问题的前提是要解决另一个（或多个）问题，这样我们就可以将原来的问题转化为其他的问题了。就好比解方程组一样，求解出了其中一个未知数，就能够求解下一条方程。 NPC问题是NP问题的子集。 很多时候NPC问题是找不到一个多项式时间算法的，更多时候他是一个指数级的算法。 最后转载一个大佬的讲解 P类问题：能在多项式时间内可解的问题。 NP类问题：在多项式时间内“可验证”的问题。也就是说，不能判定这个问题到底有没有解，而是猜出一个解来在多项式时间内证明这个解是否正确。即该问题的猜测过程是不确定的，而对其某一个解的验证则能够在多项式时间内完成。P类问题属于NP问题，但NP类问题不一定属于P类问题。 NPC问题：存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。其定义要满足2个条件： 它是一个NP问题； 所有NP问题都能规约到它。 NP难问题：NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广，NP-Hard问题没有限定属于NP），即所有的NP问题都能约化到它，但是他不一定是一个NP问题。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。 以上四个问题之间的关系如下图所示：","tags":[{"name":"算法","slug":"算法","permalink":"http://lipan.fun/tags/算法/"},{"name":"算法理论","slug":"算法理论","permalink":"http://lipan.fun/tags/算法理论/"}]},{"title":"Markdown基本语法","date":"2019-09-11T14:36:36.000Z","path":"2019/09/11/Markdown基本语法/","text":"标题二级标题三级标题四级标题五级标题六级标题 段落段落的换行是使用两个以上空格加上回车。新的段落 或者使用空出一行的方式（推荐）。 字体斜体1斜体2粗体1粗体2斜粗体1斜粗体2删除线下划线 分割线分割线有多种写法 脚注hexo需要安装插件才能使用脚注 因为页面布局问题，脚注的效果并不是很好 这是一个脚注11 生成一个脚注22 生成一个脚注33 列表无序列表无序列表有三种写法 第一项 第二项 第三项 第一项 第二项 第三项 表项1 表项2 表项3 有序列表 表项1 表项2 表项3 列表嵌套列表嵌套只需在子列表中的选项添加四个空格即可： 表项1 子表项 子表项 表项2 子表项 子表项 区块 区块效果 区块效果 区块效果 在列表中使用区块&amp;在区块中使用列表 表项 区块 1. 表项 2. 表项区块 * 表项 * 表项 区块 表项 表项 代码段落代码如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`） print() 函数的使用 代码区块代码区块使用 4 个空格或者一个制表符（Tab 键）。 public void setEmpname(String empname){ this.empname=empname; } public void setBonus(Double bonus){ this.bonus=bonus; }可以用 ``` 包裹一段代码，并指定一种语言（这样可以语法高亮，也可以不指定）： 123456public void setEmpname(String empname)&#123; this.empname=empname;&#125;public void setBonus(Double bonus)&#123; this.bonus=bonus;&#125; 123$(document).ready(function () &#123; alert('RUNOOB');&#125;); 链接注意放在脚注下的内容是无效的，所以变量要写在脚注之前Runoob百度https://www.runoob.com 图片hexo不建议使用Markdown的![]()方式引用图片，而是使用了新的方法管理图片 如果要指定图片的高度与宽度，可以使用普通的 &lt;img&gt; 标签。 表格 表头 表头 表头 单元格 单元格 单元格 单元格 单元格 单元格 1.这里是 脚注 的 内容. ↩2.这里是脚注2的内容. ↩3.这里填写需要的脚注，一般放在页面最下面 ↩","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://lipan.fun/tags/Markdown/"}]}]