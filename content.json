[{"title":"数据库基本概念","date":"2019-11-30T11:15:46.000Z","path":"2019/11/30/数据库基本概念/","text":"Redundancy 冗余Inconsistency 不一致Integrity 完整性Schema – the logical structure of the database 数据模式（数据库的总体设计）","tags":[{"name":"数据库","slug":"数据库","permalink":"http://drunkShrimper.github.io/blog/tags/数据库/"}]},{"title":"多个串的公共子序列","date":"2019-11-05T02:50:09.000Z","path":"2019/11/05/多个串的公共子序列/","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;using namespace std;int n;int a[1000000+10] = &#123;0&#125;;int len[110]= &#123;0&#125;;int xlen[110]= &#123;0&#125;;string str[110];int getXlen()&#123; for(int i=1; i&lt;n; i++) &#123; xlen[i] = 1; for(int j=1; j&lt;=i; j++) &#123; xlen[i] *= len[j] ; &#125; &#125;&#125;int mapping(int x[])&#123; int idx = x[1] ; for(int i=2; i&lt;=n; i++) &#123; idx += x[i]*xlen[i-1]; &#125; return idx;&#125;int deMapping(int m,int x[])&#123; for(int i=0; i&lt;=n; i++) x[i] = 0; for(int i=n-1; i&gt;0&amp;&amp;m!=0; i--) &#123; x[i+1] = m/xlen[i]; m = m%xlen[i] ; &#125; x[1] = m;&#125;int getF(int x[])&#123; return a[mapping(x)];&#125;void setF(int x[],int value)&#123; a[mapping(x)] = value;&#125;bool hasZero(int x[])&#123; int i; for(i=1; i&lt;=n; i++) &#123; if(x[i] == 0) return true; &#125; return false;&#125;int main()&#123; cin&gt;&gt;n; for(int i=1; i&lt;=n; i++) &#123; cin&gt;&gt;str[i]; len[i] = str[i].size() +1; &#125; getXlen(); int x[n+1] = &#123;0&#125;; for(int i=1; i&lt;=n; i++) x[i] = 0; setF(x,0); int total_len = 1; for(int i = 1; i&lt;=n; i++) &#123; total_len *= len[i]; &#125; for(int i=0; i&lt;=total_len; i++) &#123; a[i] =0; &#125; for(int i=1; i&lt;=total_len; i++) &#123; deMapping(i,x); if(hasZero(x)) &#123; setF(x,0); &#125; else &#123; int flag = 1; for(int j=1; j&lt;n; j++) &#123; if(str[j][x[j]-1] != str[j + 1][x[j+1]-1] ) &#123; flag = 0; break; &#125; &#125; if(flag) &#123; int tmp[n+1]; for(int j = 1; j&lt;=n; j++) &#123; tmp[j] = x[j]-1; &#125; setF(x,getF(tmp) + 1) ; &#125; else &#123; int tmp[n+1],max_sub = 0; for(int j = 0; j&lt;=n; j++) tmp[j] = x[j]; for(int j=1; j&lt;=n; j++) &#123; tmp[j-1] ++; tmp[j] --; if(getF(tmp) &gt; max_sub) max_sub = getF(tmp); &#125; setF(x,max_sub); &#125; &#125; &#125; int result = 0; for(int i=1;i&lt;=total_len;i++)&#123; if( a[i] &gt; result) result =a[i]; &#125; cout&lt;&lt;result; return 0;&#125;","tags":[{"name":"dp 动态规划","slug":"dp-动态规划","permalink":"http://drunkShrimper.github.io/blog/tags/dp-动态规划/"}]},{"title":"50道sql练习题","date":"2019-10-14T15:51:36.000Z","path":"2019/10/14/50道sql练习题/","text":"在网上找的50道SQL练习（使用Oracle）数据表创建 学生表 Student 12345678910111213create table Student(SId varchar(10),Sname varchar(10),Sage date,Ssex varchar(10));insert into Student values('01' , '赵雷' , to_date('1990-01-01','yyyy-MM-dd') , '男');insert into Student values('02' , '钱电' , to_date('1990-12-21','yyyy-MM-dd') , '男');insert into Student values('03' , '孙风' , to_date('1990-12-20','yyyy-MM-dd') , '男');insert into Student values('04' , '李云' , to_date('1990-12-06','yyyy-MM-dd') , '男');insert into Student values('05' , '周梅' , to_date('1991-12-01','yyyy-MM-dd') , '女');insert into Student values('06' , '吴兰' , to_date('1992-01-01','yyyy-MM-dd') , '女');insert into Student values('07' , '郑竹' , to_date('1989-01-01','yyyy-MM-dd') , '女');insert into Student values('09' , '张三' , to_date('2017-12-20','yyyy-MM-dd') , '女');insert into Student values('10' , '李四' , to_date('2017-12-25','yyyy-MM-dd') , '女');insert into Student values('11' , '李四' , to_date('2012-06-06','yyyy-MM-dd') , '女');insert into Student values('12' , '赵六' , to_date('2013-06-13','yyyy-MM-dd') , '女');insert into Student values('13' , '孙七' , to_date('2014-06-01','yyyy-MM-dd') , '女'); 科目表 Course 1234create table Course(CId varchar(10),Cname varchar(10),TId varchar(10));insert into Course values('01' , '语文' , '02');insert into Course values('02' , '数学' , '01');insert into Course values('03' , '英语' , '03'); 教师表 Teacher 1234create table Teacher(TId varchar(10),Tname varchar(10));insert into Teacher values('01' , '张三');insert into Teacher values('02' , '李四');insert into Teacher values('03' , '王五'); 成绩表 SC 12345678910111213141516171819create table SC(SId varchar(10),CId varchar(10),score decimal(18,1));insert into SC values('01' , '01' , 80);insert into SC values('01' , '02' , 90);insert into SC values('01' , '03' , 99);insert into SC values('02' , '01' , 70);insert into SC values('02' , '02' , 60);insert into SC values('02' , '03' , 80);insert into SC values('03' , '01' , 80);insert into SC values('03' , '02' , 80);insert into SC values('03' , '03' , 80);insert into SC values('04' , '01' , 50);insert into SC values('04' , '02' , 30);insert into SC values('04' , '03' , 20);insert into SC values('05' , '01' , 76);insert into SC values('05' , '02' , 87);insert into SC values('06' , '01' , 31);insert into SC values('06' , '03' , 34);insert into SC values('07' , '02' , 89);insert into SC values('07' , '03' , 98); 练习题目题组1题型1 查询” 01 “课程比” 02 “课程成绩高的学生的信息及课程分数 1234select t1.*,t2.score 课程02分数 from (select * from SC natural join student where sc.cid = '01') t1, (select * from SC natural join student where sc.cid = '02') t2where t1.score &gt; t2.score and t1.sid = t2.sid; 查询同时存在” 01 “课程和” 02 “课程的情况 1234select t1.*,t2.score 课程02分数 from (select * from SC natural join student where sc.cid = '01') t1, (select * from SC natural join student where sc.cid = '02') t2where t1.sid = t2.sid; 查询存在” 01 “课程但可能不存在” 02 “课程的情况(不存在时显示为 null ) 1234select t1.*,t2.score 课程02分数 from (select * from SC natural join student where sc.cid = '01') t1 left join(select * from SC natural join student where sc.cid = '02') t2on t1.sid = t2.sid; 查询不存在” 01 “课程但存在” 02 “课程的情况 123select * from (select * from SC natural join student where sc.cid = '02') where sid not in(select sid from SC where cid = '01') ; 题型2 查询平均成绩大于等于 60 分的同学的学生编号和学生姓名和平均成绩 1234select s.sid,s.sname,t.avg_score from student s, (select sid,avg(score) avg_score from SC group by sid) t where s.sid = t.sid and t.avg_score&gt;60; 1234select s.sid,s.sname,t.avg_score from student s, (select sid,avg(score) avg_score from SC group by sid having avg(score)&gt;60) twhere s.sid = t.sid; 题型3 查询在 SC 表存在成绩的学生信息 1select * from student where sid in (select distinct sid from SC); 1select DISTINCT student.* from student,sc where student.SId=sc.SId; 题型4 查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩(没成绩的显示为 null ) 1234select s.sid,s.sname,t.count_course,t.sum_score from student s, (select sid,count(cid) count_course,sum(score) sum_score from SC group by sid) t where s.sid = t.sid; 12345select s.sid,s.sname,t.count_course,t.sum_score from student s left join (select sid,count(cid) count_course,sum(score) sum_score from SC group by sid) t on s.sid = t.sid; 查有成绩的学生信息 这里涉及到一个知识点：当表2的记录数量非常大的时候，选用exists比in要高效很多 EXISTS用于检查子查询是否至少会返回一行数据，该子查询实际上并不返回任何数据，而是返回值True或False.结论：IN()适合B表比A表数据小的情况结论：EXISTS()适合B表比A表数据大的情况 1select * from student where sid in (select distinct sid from SC); 12select * from student where exists (select sc.sid from sc where student.sid = sc.sid); 题型5 查询「李」姓老师的数量 1select count(*) from teacher where tname like '李_%'; 题型6 查询学过「张三」老师授课的同学的信息 先上一种笨方法 1234select * from student where sid in (select sid from sc where cid = ( select cid from course where tid = (select tid from teacher where tname = '张三'))); 下面的方法一开始理解起来有些困难，但这是很普通的多表联查 123456select student.* from student,teacher,course,scwhere student.sid = sc.sid and course.cid=sc.cid and course.tid = teacher.tid and tname = '张三'; 题型7 查询没有学全所有课程的同学的信息 第一种做法忽略了有的学生一门课都没学的情况（所以其sid不会出现在SC表） 123select * from student where sid in (select sid from sc group by sid having count(cid) &lt;(select count(cid) from course)); 正确的做法应该是先查出修了所有课程的学生，再求其相对于所有学生集的补集 123456select * from studentwhere student.sid not in ( select sc.sid from sc group by sc.sid having count(sc.cid)= (select count(cid) from course)); 题型8 查询至少有一门课与学号为” 01 “的同学所学相同的同学的信息 思路：student表要和SC表作联合查询这是毫无疑问的，在查询时要多加一个限制条件“课程id要属于学号为” 01 “的同学所学的课程id集合” 同理可以使用natural join，实质上natural join跟表联查是等价的。 123select distinct student.* from student,SC where SC.cid in (select cid from SC where sid = '01') and student.sid=SC.sid; 题型9 查询和” 01 “号的同学学习的课程完全相同的其他同学的信息 这题本来不用写这么长但是由于这个操作：”取一个中间表的某字段最大的记录（即：top N问题）“使得这个查询变得很长，实际上没有这么长 分析： 首先取出sid为“01”的学生学习的所有课程的cid，这个应该不难 然后根据SC表中每个学生的每门成绩有且仅有一条记录这个原则： 查询出SC中所有学生中有学习“01”学生学习的课程的记录 对上一条操作得到的中间表进行分组（根据sid），并计算count(cid) 如果某学生的count(cid)和”01“学生的count(cid)相同，则说明他们所学习的课程完全一样。同样的，如果某学生的count(cid)小于”01“学生的count(cid)，说明他学的课有和”01“学生相同的，但没有学完”01“学生学的所有课。如果某学生并不在这个查询结果内，说明他学的课没有一门是”01“学生学的课。 最后根据题目要求还要排除“01”学生这条记录 1234567select s.* from student s,(select * from (select sid,count(cid) same_num from SC where cid in (select cid from SC where sid = '01') group by sid)where same_num = (select count(cid) from SC where sid ='01')) twhere s.sid =t.sid and s.sid &lt;&gt; '01'; 123456select s.* from student s,(select sid from SC where cid in (select cid from SC where sid = '01') group by sid havingcount(cid) = (select count(cid) from SC where sid ='01')) twhere s.sid =t.sid and s.sid &lt;&gt; '01'; 题型10 查询没学过”张三”老师讲授的任一门课程的学生姓名 这题思路跟题型7一样，要查没学过“张三”老师的课的学生，应该先查学过的，在求补集。如果直接求的话，会出现有人一门课都没学过的情况。 123select * from student where sid not in (select sid from sc where cid in (select cid from course where tid = (select tid from teacher where tname = '张三') )); 12345678select * from studentwhere student.sid not in( select sc.sid from sc,course,teacher where sc.cid = course.cid and course.tid = teacher.tid and teacher.tname= \"张三\"); 题组2题型1 查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩 12345select s.sid 学号,s.sname 姓名,t2.avg_score 平均成绩 from student s,(select sid from sc where score&lt;60 group by sid having count(cid)&gt;1) t1,(select sid,avg(score) avg_score from sc group by sid) t2where t1.sid = t2.sid and s.sid = t1.sid; 题型2 检索” 01 “课程分数小于 60，按分数降序排列的学生信息 123select * from student natural join sc where score &lt;60 and cid = '01' order by score desc ; 题型3 按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩 此题本身难倒是不难，反而是如何显示要下一番功夫 1234select * from (select * from sc union select sid,'avg' cid,avg(score) score from sc group by sid) order by sid,case when cid = 'avg' then 1 else 0 end asc,score desc; 题型4 查询各科成绩最高分、最低分和平均分： 以如下形式显示：课程 ID，课程 name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率 及格为&gt;=60，中等为：70-80，优良为：80-90，优秀为：&gt;=90 要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列 这里没有查出课程名，如果要查的话natural join一下course表即可 12345678910111213select cid 课程ID,count(*) 选修人数,max(sc.score) 最高分,min(sc.score) 最低分,AVG(sc.score) 平均分,sum(case when sc.score&gt;=60 then 1 else 0 end )/count(*) 及格率,sum(case when sc.score&gt;=70 and sc.score&lt;80 then 1 else 0 end )/count(*) 中等率,sum(case when sc.score&gt;=80 and sc.score&lt;90 then 1 else 0 end )/count(*) 优良率,sum(case when sc.score&gt;=90 then 1 else 0 end )/count(*) 优秀率 from scGROUP BY cidORDER BY count(*) DESC, cid ASC; 题型5 按各科成绩进行排序，并显示排名， Score 重复时保留名次空缺 思路: 首先查出比自己高分的记录有多少条，注意利用左连接的特点使得第一名（因为没有人比他高分，不使用左连接的话会没有第一名的记录比较麻烦）能被记录。 1234select *from sc a left join sc b on a.score&lt;b.score and a.cid = b.cid order by a.sid; 在得到的上表中，对于sid来说有多少条记录就说明排名是多少,但是因为需求是 Score 重复时保留名次空缺，因此不用count(a.sid)(或count(a.cid),count(a.score))而是使用count(b.score)+1,这样在计数比自己高的人数时就不会把自己算进去（因为使用的是left join,自己那一条记录的b.score是为null 的） 123456select a.cid, a.sid, a.score, count(b.score)+1 rankfrom sc a left join sc b on a.score&lt;b.score and a.cid = b.cidgroup by a.cid, a.sid,a.scoreorder by a.cid, rank ASC; 按各科成绩进行排序，并显示排名， Score 重复时不保留名次空缺 此题与题型6的第2题情况一样 题型6 查询学生的总成绩，并进行排名，总分重复时保留名次空缺 与题型5第1题解法类似 12345select t.sid,t.score,count(t2.score)+1 rank from (select sid,sum(score) score from sc group by sid) t left join (select sid,sum(score) score from sc group by sid) t2 on t.score&lt;t2.score group by t.sid,t.score order by count(*); 查询学生的总成绩，并进行排名，总分重复时不保留名次空缺 这题没什么好思路，直接抄的别人的答案。在SQL里面变量用@来标识。但是在Oracle中的语法好像不是这样定义变量的，还是说应该使用plsql来解决？（下面是mysql的解法） 12345set @crank=0;select q.sid, total, @crank := @crank +1 as rank from(select sc.sid, sum(sc.score) as total from scgroup by sc.sidorder by total desc)q; 题型7 统计各科成绩各分数段人数：课程编号，课程名称，[100-85]，[85-70]，[70-60]，[60-0] 及所占百分比 这里要注意case when 条件 then 1 else 0 end的原理，它是返回数值1或0，如果使用count来接收的话，不论是1还是0都会计数。效果跟count(*)一样，所以此处应该使用sum来计数，如果还不明白，将sum(case when 条件 then 2 else 0 end)和count(case when 条件 then 2 else 0 end)查询一下就明白了。 1234567891011121314select cid,cname,sum(case when score&gt;=85 and score &lt;=100 then 1 else 0 end) \"[100-85]人数\",sum(case when score&gt;=70 and score &lt;85 then 1 else 0 end) \"[85-70]人数\",sum(case when score&gt;=60 and score &lt;70 then 1 else 0 end) \"[70-60]人数\",sum(case when score&gt;=0 and score &lt;60 then 1 else 0 end) \"[60-0]人数\",round(sum(case when score&gt;=85 and score &lt;=100 then 1 else 0 end)/count(*),2) \"[100-85]比例\",round(sum(case when score&gt;=70 and score &lt;85 then 1 else 0 end)/count(*),2) \"[85-70]比例\",round(sum(case when score&gt;=60 and score &lt;70 then 1 else 0 end)/count(*),2) \"[70-60]比例\",round(sum(case when score&gt;=0 and score &lt;60 then 1 else 0 end)/count(*),2) \"[60-0]比例\"from sc natural join course group by cid,cname; 题型8 查询各科成绩前三名的记录 这个题目还是有点麻烦，因为Oracle不支持像mysql里面的limit语法。这里查询了一下资料，可以使用OVER(PARTITION BY)函数。附上一篇讲解博客。 123select * from (select sc.*,row_number() over(partition by cid order by score desc ) rank from sc) where rank &lt; 4; 但是上面的解法有个问题，如果有相同分数的就有点难办了。所以还是得用“找出比自己高分的人数”的思路来确定自己的排名。解法如下： 123select * from scwhere (select count(*) from sc a where sc.cid = a.cid and sc.score&lt;a.score )&lt; 3order by cid asc, sc.score desc; 题组3题目1 查询每门课程被选修的学生数 查成绩单上每门课对应的记录条数即可。 1select cid,count(*) from sc group by cid; 题目2 查询出只选修两门课程的学生学号和姓名 1select sid,sname from sc natural join student group by sid,sname having count(*) =2; 题目3 查询男生、女生人数 1select ssex 性别,count(*) 人数 from student group by ssex; 题目4 查询名字中含有「风」字的学生信息 1select *from student where sname like '%风%'; 题目5 查询同名同性学生名单，并统计同名人数 123select s1.sname 姓名,count(*) 人数 from student s1,student s2 where s1.sid &lt;&gt; s2.sid and s1.sname = s2.sname group by s1.sname; 题目6 查询 1990 年出生的学生名单 注：在Oracle里面没有year()函数 1select * from student where to_char(sage,'YYYY') = '1990' ; 题目7 查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列 123select cname,cid,round(avg(score),2) from sc natural join course group by cid,cname order by avg(score) desc,cid asc; 题目8 查询平均成绩大于等于 85 的所有学生的学号、姓名和平均成绩 1select sid,sname,round(avg(score),2) from student natural join sc group by sname,sid having avg(score) &gt;=85; 题目9 查询课程名称为「数学」，且分数低于 60 的学生姓名和分数 1234select sname,score from sc,course,student where sc.cid = course.cid and course.cname = '数学' and sc.sid = student.sid and sc.score&lt;60; 题目10 查询所有学生的课程及分数情况（存在学生没成绩，没选课的情况） 123select student.sid,sname,cname,score from student left join (select * from sc natural join course) t on student.sid = t.sid; 题组4题目1 查询任何一门课程成绩在 70 分以上的姓名、课程名称和分数 123select sname,cname,score from student natural join sc natural join coursewhere score&gt;70; 解法2： 1234select student.sname, course.cname,sc.score from student,course,scwhere sc.score&gt;70and student.sid = sc.sidand sc.cid = course.cid; 题目2 查询存在有人不及格的课程 1select distinct cname from sc natural join course where score &lt; 60; 题目3 查询课程编号为 01 且课程成绩在 80 分以上的学生的学号和姓名 1select sid,sname from sc natural join student where score &gt;= 80 and cid = '01'; 题目4 求每门课程的学生人数 1select cname,count(sid) from sc natural join course group by cname; 题目5 成绩不重复，查询选修「张三」老师所授课程的学生中，成绩最高的学生信息及其成绩 要注意一个老师是可以有多门课的，这里的数据恰好是只有一门课。 1234567select student.*,t.* from sc ,student,(select cid,max(score) score from sc where cid in(select cid from course natural join teacher where tname ='张三') group by cid) twhere sc.sid = student.sid and sc.cid = t.cid and sc.score = t.score; 题目6 查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩 12select t1.* from sc t1 inner join sc t2 on t1.cid = t2.cid and t1.score = t2.score and t1.sid &lt;&gt; t2.sid order by t1.cid; 题目7 查询每门课成绩排名前2的学生 这题在Oracle里面还是比较麻烦，解题思路跟题组2 题型5差不多 1234select t1.cid,t1.sid,count(*) from sc t1 left join sc t2 on t2.score&gt;t1.score and t1.sid &lt;&gt; t2.sid and t1.cid = t2.cid group by t1.cid,t1.sid having count(*)&lt;=2 order by cid; 题目8 统计每门课程的学生选修人数（超过 5 人的课程才统计） 1select cid,count(*) from sc group by cid having count(*) &gt;5; 题目9 检索至少选修两门课程的学生学号 1select sid from sc group by sid having count(cid) &gt;=2 order by sid; 题目10 查询选修了全部课程的学生信息 12select * from student where sid in (select sid from sc group by sid having count(cid) =(select count(*) from course)); 题组5题目1 查询各学生的年龄，只按年份来算 1select sname,round(months_between(sysdate,sage)/12,0) 年龄 from student; 题目2 查询本周过生日的学生 在oracle里面貌似比较难实现… 思路：首先将出生日期的年份替换为当前年份，然后看这个日期是今年的第几周，是否与当前时间是当前第几周相同。（感觉解法是错的…有待研究） 123select sid from student where to_char(add_months(sage,(to_char(sysdate,'yyyy') - to_char(sage,'yyyy'))*12),'ww') = to_char(sysdate,'ww'); 题目3 查询下周过生日的学生 这题要考虑边界情况，如果下周是下一年了就比较难搞了…（有待研究） 12 题目4 查询本月过生日的学生 1select * from student where to_char(sysdate,'MM') = to_char(sage,'MM'); 题目5 查询下月过生日的学生 1select * from student where MOD(to_char(sysdate,'MM')+1,13)= to_char(sage,'MM');","tags":[{"name":"sql","slug":"sql","permalink":"http://drunkShrimper.github.io/blog/tags/sql/"}]},{"title":"算法:数的统计问题","date":"2019-09-24T10:03:52.000Z","path":"2019/09/24/算法-数的统计问题/","text":"问题描述 一本书的页码从自然数1开始顺序编码直到自然数n。书的页码按照通常的习惯编排 ，每个页码都不含多余的前导数字0。例如第6页用6表示而不是06或006。数字统计问题要求对给定书的总页码，计算出书的全部页码中分别用到多少次数字0,1,2,3,…..9。 解法1：暴力求解这个没什么好说的，有编程基础的都会 12345678910111213141516171819202122#include&lt;stdio.h&gt;using namespace std;int main()&#123; int n; scanf(\"%d\",&amp;n); long totalNum[10] = &#123;0&#125;; int tmp; for(int i=1;i&lt;=n;i++)&#123; tmp = i; while(tmp)&#123; totalNum[tmp%10]+=1; tmp/=10; &#125; &#125; for(int i=0;i&lt;10;i++)&#123; printf(\"%ld\",totalNum[i]); &#125;&#125; 解法2：递归求解","tags":[{"name":"递归","slug":"递归","permalink":"http://drunkShrimper.github.io/blog/tags/递归/"}]},{"title":"算法理论之p问题、NP问题、NP完全问题与NP难问题","date":"2019-09-17T12:20:44.000Z","path":"2019/09/17/算法理论之p问题、NP问题、NP完全问题与NP难问题/","text":"基础知识回顾要了解上面的算法概念，首先要回顾一下这两个基本的数学概念 多项式函数 形如：形如 Pn(x)=a(n)x^n+a(n-1)x^(n-1)+…+a(1)x+a(0)的函数，叫做多项式函数 例如：y=kx+b 就是一个次数是1的多项式函数，y=ax^2+bx+c就是一个次数为2的多项式函数 时间复杂度 这个东西用大白话来讲就是衡量一个算法优劣的最重要指标，例如冒泡算法的时间复杂度是o(n^2)，其中n是指数据的规模。这里面的n^2就是一个多项式。 那么什么是p类问题例如冒泡算法的时间复杂度是o(n^2)，它是一个多项式时间的算法问题，所以我们将之称为P类问题(P：polynominal，多项式)。 NP问题的定义NP类问题：能在多项式时间内验证得出一个正确解的问题。(NP:Nondeterministic polynominal，非确定性多项式) P类问题是NP问题的子集，因为存在多项式时间解法的问题，总能在多项式时间内验证他。 如何理解NP问题呢？ 我们可以这样想：有一个问题，你不知道是否存在一个多项式算法来解决它，但是你可以通过一次次的猜测（或者说尝试）从而有机会在一个多项式的时间呢找出他的解。这种不确定性就可以称之为N。这样的问题就是NP问题啦。 NPC问题NPC问题:如果所有np问题都能在多项式时间内转化为他，则称该np问题为npc问题(NPC:NP complete又叫NP完全问题) 那么啥叫问题的转化呢？我们用最直白的想法来理解就是：要解决一个问题的前提是要解决另一个（或多个）问题，这样我们就可以将原来的问题转化为其他的问题了。就好比解方程组一样，求解出了其中一个未知数，就能够求解下一条方程。 NPC问题是NP问题的子集。 很多时候NPC问题是找不到一个多项式时间算法的，更多时候他是一个指数级的算法。 感觉写的有点烂，最后转载一个大佬的讲解 P类问题：能在多项式时间内可解的问题。 NP类问题：在多项式时间内“可验证”的问题。也就是说，不能判定这个问题到底有没有解，而是猜出一个解来在多项式时间内证明这个解是否正确。即该问题的猜测过程是不确定的，而对其某一个解的验证则能够在多项式时间内完成。P类问题属于NP问题，但NP类问题不一定属于P类问题。 NPC问题：存在这样一个NP问题，所有的NP问题都可以约化成它。换句话说，只要解决了这个问题，那么所有的NP问题都解决了。其定义要满足2个条件： 它是一个NP问题； 所有NP问题都能规约到它。 NP难问题：NP-Hard问题是这样一种问题，它满足NPC问题定义的第二条但不一定要满足第一条（就是说，NP-Hard问题要比 NPC问题的范围广，NP-Hard问题没有限定属于NP），即所有的NP问题都能约化到它，但是他不一定是一个NP问题。NP-Hard问题同样难以找到多项式的算法，但它不列入我们的研究范围，因为它不一定是NP问题。即使NPC问题发现了多项式级的算法，NP-Hard问题有可能仍然无法得到多项式级的算法。事实上，由于NP-Hard放宽了限定条件，它将有可能比所有的NPC问题的时间复杂度更高从而更难以解决。 以上四个问题之间的关系如下图所示：","tags":[{"name":"算法理论","slug":"算法理论","permalink":"http://drunkShrimper.github.io/blog/tags/算法理论/"}]},{"title":"Markdown基本语法","date":"2019-09-11T14:36:36.000Z","path":"2019/09/11/Markdown基本语法/","text":"标题二级标题 三级标题四级标题五级标题六级标题 段落段落的换行是使用两个以上空格加上回车。新的段落 或者使用空出一行的方式（推荐）。 字体斜体1斜体2粗体1粗体2斜粗体1斜粗体2删除线下划线 分割线分割线有多种写法 脚注hexo需要安装插件才能使用脚注 因为页面布局问题，脚注的效果并不是很好 这是一个脚注11 生成一个脚注22 生成一个脚注33 列表无序列表无序列表有三种写法 第一项 第二项 第三项 第一项 第二项 第三项 表项1 表项2 表项3 有序列表 表项1 表项2 表项3 列表嵌套列表嵌套只需在子列表中的选项添加四个空格即可： 表项1 子表项 子表项 表项2 子表项 子表项 区块 区块效果 区块效果 区块效果 在列表中使用区块&amp;在区块中使用列表 表项 区块 1. 表项 2. 表项区块 * 表项 * 表项 区块 表项 表项 代码段落代码如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`） print() 函数的使用 代码区块代码区块使用 4 个空格或者一个制表符（Tab 键）。 public void setEmpname(String empname){ this.empname=empname; } public void setBonus(Double bonus){ this.bonus=bonus; }可以用 ``` 包裹一段代码，并指定一种语言（这样可以语法高亮，也可以不指定）： 123456public void setEmpname(String empname)&#123; this.empname=empname;&#125;public void setBonus(Double bonus)&#123; this.bonus=bonus;&#125; 123$(document).ready(function () &#123; alert('RUNOOB');&#125;); 链接注意放在脚注下的内容是无效的，所以变量要写在脚注之前Runoob百度https://www.runoob.com 图片hexo不建议使用Markdown的![]()方式引用图片，而是使用了新的方法管理图片 如果要指定图片的高度与宽度，可以使用普通的 &lt;img&gt; 标签。 表格 表头 表头 表头 单元格 单元格 单元格 单元格 单元格 单元格 1.这里是 脚注 的 内容. ↩2.这里是脚注2的内容. ↩3.这里填写需要的脚注，一般放在页面最下面 ↩","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://drunkShrimper.github.io/blog/tags/Markdown/"}]},{"title":"总结过去与展望未来","date":"2019-09-11T14:03:36.000Z","path":"2019/09/11/总结过去与展望未来/","text":"向过去说再见大学生活注定是有苦有乐的。从大一的一腔热血、懵懵懂懂，到大二的得过且过与迷茫。再到大三重新设立目标，再次上路。过去的你是怎样的已经不重要了，重要的是你现在要做什么，你以后要做什么。大一时天真无邪，以为高三奋斗了好久啊，现在终于上到了大学，可以有一份还算是不错的工作。能够让家人不用日晒雨淋的日子了。 然而现实总是很残酷，以为上到大学，大家都是积极向上努力奋斗的。可是总会有些得过且过的人在影响这你。大学的课程，上课水一水，作业上网cv一下。期末考前背一背，还能考到个不错的成绩。甚至还沾沾自喜，以为自己找到了大学生活的诀窍。 然而，不管过去的你是如何的，只要能够设立目标，重新上路，努力提升自己，那就是最好的。 拥抱新生活在写这个博客时，我也是下了不少的决心的，因为自己的技术水平还远远不过关。还要花时间精力在写博客上，是不是太浪费时间了。然而，尽管自己还有很多需要努力的地方，还有继续奋斗。我还是想通过博客的方式记录一下自己的生活，不仅是技术上的，也是生活上的。 希望自己能过在接下来的日子里努力奋斗，一点一点的提升自己。因为大三还是有一些课程需要上（尽管我觉得听那些老师讲课并没有什么用，还不如自己跟着mooc学习），不能专心于自己的学习计划。所以我决定先给自己定几个短期的小目标，循序渐进。 同时也希望那些还在迷茫中的朋友能够尽快找到奋斗的目标，不断前进！ 短期计划 花大概一小时的时间学习Markdown语法，并使用博客记录学习笔记 将一些比较重要的有道云笔记的学习记录搬运过来 学习常用的办公软件 word Excel PPT","tags":[{"name":"情感","slug":"情感","permalink":"http://drunkShrimper.github.io/blog/tags/情感/"}]}]